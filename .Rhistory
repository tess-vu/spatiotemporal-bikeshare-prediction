) +
theme_plot() +
theme(axis.text.x = element_text(angle = 45, hjust = 1))
temp_error_plot
#| message: false
#| warning: false
#| fig-dpi: 300
#| fig-height: 14
#| fig-width: 12
# Attach census variables to station-level errors.
station_errors_demo_q4 <- station_errors_q4 %>%
left_join(
station_census_lookup %>%
select(start_station_id, med_inc, pct_public_commute, pct_white),
by = "start_station_id"
) %>%
filter(!is.na(med_inc))
# MAE vs Median Income
mae_inc_q4_map <- ggplot(station_errors_demo_q4, aes(x = med_inc, y = MAE)) +
geom_point(alpha = 0.5, color = "#011f5b") +
geom_smooth(method = "lm", se = FALSE, color = "#990000", linetype = "dashed") +
scale_x_continuous(labels = scales::dollar) +
labs(
title = "Prediction Errors vs. Median Income",
subtitle = "2024 Q4",
x = "Median Income.",
y = "MAE"
) +
theme_plot()
# MAE vs Public Transit Usage
mae_pub_q4_map <- ggplot(station_errors_demo_q4, aes(x = pct_public_commute, y = MAE)) +
geom_point(alpha = 0.5, color = "#011f5b") +
geom_smooth(method = "lm", se = FALSE, color = "#990000", linetype = "dashed") +
labs(
title = "Prediction Errors vs. Transit Usage",
subtitle = "2024 Q4",
x = "% Taking Transit.",
y = "MAE"
) +
theme_plot()
# MAE vs Percent White
mae_yt_q4_demo <- ggplot(station_errors_demo_q4, aes(x = pct_white, y = MAE)) +
geom_point(alpha = 0.5, color = "#011f5b") +
geom_smooth(method = "lm", se = FALSE, color = "#990000", linetype = "dashed") +
labs(
title = "Prediction Errors vs. Percent White",
subtitle = "2024 Q4",
x = "% White",
y = "MAE"
) +
theme_plot()
mae_inc_q4_map / mae_pub_q4_map / mae_yt_q4_demo
#| message: false
#| warning: false
# Poisson regression.
poisson_model <- glm(
trips ~ as.factor(hour) + dow_simple + temp + precip +
# New variables.
days_since_oct1 + is_too_cold +
lag_1hr + lag_3hr + lag_1day +
(is_too_cold * days_since_oct1),
data = train_clean,
family = poisson(link = "log")
)
summary(poisson_model)
# Compare to OLS.
test_clean$pred_poisson <- predict(poisson_model, newdata = test_clean, type = "response")
mae_poisson <- mean(abs(test_clean$trips - test_clean$pred_poisson), na.rm = TRUE)
cat("OLS Updated Model 2 MAE:", round(mae_update, 4), "\n")
cat("Poisson Model MAE:", round(mae_poisson, 4), "\n")
#| fig-dpi: 300
#| fig-height: 10
#| fig-width: 10
# Station improvement.
station_improvements <- test_clean %>%
group_by(start_station_id, start_lat, start_lon) %>%
summarize(
mae_model2 = mean(abs(trips - pred2), na.rm = TRUE),
mae_update = mean(abs(trips - pred_update), na.rm = TRUE),
improvement = mae_model2 - mae_update,
.groups = "drop"
)
# Improvement map.
improvement_map <- ggplot() +
geom_sf(data = philly_census, fill = "#4c6e52", color = "#f5f4f0", linewidth = 0.5) +
geom_point(
data = station_improvements,
aes(x = start_lon, y = start_lat, color = improvement, size = abs(improvement)),
alpha = 0.8
) +
scale_color_gradient2(
low = "#0889bc", mid = "#fef7d7", high = "#e83b2e",
midpoint = 0,
name = "MAE Change"
)+
guides(
size = guide_legend(order = 1),
color = guide_colorbar(order = 2)
) +
labs(
title = "Model Improvement by Indego Station",
subtitle = "Philadelphia, PA",
caption = "Positive values indicate better predictions with new features.",
size = "Absolute Improvement"
) +
theme_map() +
theme(
legend.box = "vertical"
)
improvement_map
#| message: false
#| warning: false
#| fig-dpi: 300
#| fig-height: 18
#| fig-width: 12
station_census_lookup$pct_non_yt <- (1 - station_census_lookup$pct_white)
# Census and avg_demand to station-level improvements.
improvement_demo <- station_improvements %>%
left_join(
# Demographics.
station_census_lookup %>%
select(start_station_id, med_inc, pct_public_commute, pct_non_yt),
by = "start_station_id"
) %>%
left_join(
# Join average demand data from error summary.
station_errors_q4 %>%
select(start_station_id, avg_demand),
by = "start_station_id"
) %>%
filter(!is.na(med_inc))
mae_poc_improvement_plot <- ggplot(improvement_demo, aes(x = pct_non_yt, y = improvement)) +
geom_point(aes(size = avg_demand), alpha = 0.5, color = "#EF4269") +
geom_hline(yintercept = 0, linetype = "dashed", color = "#1A1851", linewidth = 1) +
geom_smooth(method = "lm", se = TRUE, color = "#C5A453", linetype = "longdash", linewidth = 1) +
scale_x_continuous(labels = scales::percent) +
labs(
title = "Model Improvement by Station",
subtitle = "% Non-White Population",
x = "% Non-White",
y = "MAE Improvement (Trips per Hour)",
size = "Average Demand"
) +
theme_plot()
mae_inc_improvement_plot <- ggplot(improvement_demo, aes(x = med_inc, y = improvement)) +
geom_point(aes(size = avg_demand), alpha = 0.5, color = "#EF4269") +
geom_hline(yintercept = 0, linetype = "dashed", color = "#1A1851", linewidth = 1) +
geom_smooth(method = "lm", se = TRUE, color = "#C5A453", linetype = "longdash", linewidth = 1) +
scale_x_continuous(labels = scales::dollar) +
labs(
title = "Model Improvement by Station",
subtitle = "Median Income",
x = "Median Income",
y = "MAE Improvement (Trips per Hour)",
size = "Average Demand"
) +
theme_plot()
mae_pub_improvement_plot <- ggplot(improvement_demo, aes(x = pct_public_commute, y = improvement)) +
geom_point(aes(size = avg_demand), alpha = 0.5, color = "#EF4269") +
geom_hline(yintercept = 0, linetype = "dashed", color = "#1A1851", linewidth = 1) +
geom_smooth(method = "lm", se = TRUE, color = "#C5A453", linetype = "longdash", linewidth = 1) +
scale_x_continuous(labels = scales::percent) +
labs(
title = "Model Improvement by Station",
subtitle = "% Public Transit Commuters",
caption = "Points above the dashed line show improvement (MAE decrease).\nChange in MAE (Old MAE - New MAE) vs. Median Income",
x = "Median Income",
y = "MAE Improvement (Trips per Hour)",
size = "Average Demand"
) +
theme_plot()
mae_poc_improvement_plot / mae_inc_improvement_plot / mae_pub_improvement_plot
#| fig-height: 8
#| fig-width: 12
#| fig-dpi: 300
temporal_bias_q4 <- test_q4_error %>%
group_by(hour, is_weekend) %>%
summarize(
mean_error = mean(error, na.rm = TRUE),
.groups = "drop"
) %>%
mutate(day_type = ifelse(is_weekend, "Weekend", "Weekday"))
bias_plot <- ggplot(temporal_bias_q4, aes(x = hour, y = mean_error, color = day_type)) +
geom_hline(yintercept = 0, linetype = "dashed", color = "#f48f33", linewidth = 1) +
geom_line(linewidth = 1.5) +
geom_point(size = 3) +
scale_color_manual(values = c("Weekday" = "#08519c", "Weekend" = "#6baed6")) +
labs(
title = "Prediction Bias by Hour and Day Type",
subtitle = "2024 Q4 Test Set",
caption = "Positive values mean the model under-predicts (demand > prediction).\nMean Error (Actual Trips - Predicted Trips)",
x = "Hour of Day",
y = "Mean Error (Trips per Hour)",
color = "Day Type"
) +
theme_plot()
bias_plot
#| message: false
#| warning: false
#| fig-dpi: 300
#| fig-height: 8
#| fig-width: 10
test_clean <- test_clean %>%
mutate(residual = trips - pred_update)
temp_residuals_plot <- ggplot(test_clean, aes(x = temp, y = residual)) +
geom_point(alpha = 0.1, color = "#EF4269") +
geom_hline(yintercept = 0, linetype = "dashed", color = "#C5A453", linewidth = 1) +
geom_smooth(method = "loess", color = "#778ac5", se = FALSE, linewidth = 1) +
labs(
title = "Model Residuals vs. Temperature",
subtitle = "Updated OLS Model (2024 Q4 Test Set)",
caption = "Blue curve is the average bias across temperature.",
x = "Temperature (°F)",
y = "Residual (Actual Trips - Predicted Trips)"
) +
theme_plot()
temp_residuals_plot
#| message: false
#| warning: false
# Play around with predictor columns.
update_model <- lm(
trips ~ as.factor(hour) + dow_simple + temp + precip +
# New variables.
days_since_oct1 + is_too_cold +
lag_1hr + lag_3hr + lag_1day +
(is_too_cold * days_since_oct1),
data = train_clean
)
# Compare updated best model to best model.
test_clean$pred_update <- predict(update_model, newdata = test_clean)
mae_update <- mean(abs(test_clean$trips - test_clean$pred_update), na.rm = TRUE)
mae_model2 <- mean(abs(test_clean$trips - test_clean$pred2), na.rm = TRUE)
cat("Model 2 MAE:", round(mae_model2, 4), "\n")
cat("Updated Model 2 MAE:", round(mae_update, 4), "\n")
cat("Improvement:", round(mae_model2 - mae_update, 4), "trips per hour\n")
cat("Percent Improvement:", round(100 * (mae_model2 - mae_update) / mae_model2, 2), "%\n")
#| message: false
#| warning: false
library(tidyverse)
library(lubridate)
library(janitor)
library(zoo)
library(sf)
library(tigris)
library(tidycensus)
library(viridis)
library(knitr)
library(kableExtra)
library(patchwork)
library(scales)
library(showtext)
library(sysfonts)
library(glmnet)
library(fixest)
# Avoid spherical issues with joins.
sf_use_s2(FALSE)
# Load fonts
font_add_google("Outfit", "outfit")
font_add_google("Anonymous Pro", "anonymous")
showtext_opts(dpi = 300)
showtext_auto()
# Get rid of scientific notation.
options(scipen = 999)
# Save figures.
knitr::opts_chunk$set(
dev = "png",
fig.path = "figures/"
)
# Create custom plot theme for charts.
theme_plot <- function(base_size = 11) {
theme_minimal(base_size = base_size) +
theme(
# Set title styling with custom font and color.
plot.title = element_text(face = "bold",
family = "outfit",
color = "#2d2a26",
size = base_size + 1,
hjust = 0.5
),
# Set subtitle with italic styling.
plot.subtitle = element_text(face = "italic",
family = "outfit",
color = "#51534a",
size = base_size - 1,
hjust = 0.5,
margin = margin(b = 0.5, unit = "cm")
),
# Set caption styling for source notes.
plot.caption = element_text(face = "italic",
family = "anonymous",
color = "#9b9e98",
size = base_size - 2
),
# Position legend at bottom.
legend.position = "bottom",
# Set grid line colors.
panel.grid.major = element_line(colour = "#d4d2cd"),
panel.grid.minor = element_line(colour = "#d4d2cd"),
# Style axis text and titles.
axis.text = element_text(face = "italic",
family = "anonymous",
size = base_size - 2,
hjust = 0.5
),
axis.title = element_text(face = "bold",
family = "anonymous",
size = base_size - 1,
hjust = 0.5
),
# Add spacing around axis titles.
axis.title.y = element_text(margin = margin(r = 0.5, unit = "cm")
),
axis.title.x = element_text(margin = margin(t = 0.5, unit = "cm")
),
# Style legend elements.
legend.title = element_text(face = "italic",
family = "anonymous",
size = base_size - 1,
hjust = 0.5
),
legend.title.position = "top",
legend.text = element_text(face = "italic",
family = "anonymous",
size = base_size - 2,
hjust = 0.5
),
# Set legend key dimensions.
legend.key.width = unit(2, "cm"),
legend.key.height = unit(0.5, "cm"),
# Set background colors for consistent appearance.
legend.background = element_rect(fill = "#f5f4f0", color = "#f5f4f0"),
plot.background = element_rect(fill = "#f5f4f0", color = "#f5f4f0"),
panel.background = element_rect(fill = "#f5f4f0", color = "#f5f4f0"),
# Add plot margins.
plot.margin = unit(c(1, 1, 1, 1), "cm")
)
}
# Create custom theme for maps.
# Similar to plot theme but removes axis elements.
theme_map <- function(base_size = 11) {
theme_minimal(base_size = base_size) +
theme(
plot.title = element_text(face = "bold",
family = "outfit",
color = "#2d2a26",
size = base_size + 1,
hjust = 0.5
),
plot.subtitle = element_text(face = "italic",
family = "outfit",
color = "#51534a",
size = base_size - 1,
hjust = 0.5,
margin = margin(b = 0.5, unit = "cm")
),
plot.caption = element_text(face = "italic",
family = "anonymous",
color = "#9b9e98",
size = base_size - 3
),
legend.position = "bottom",
# Remove grid lines for maps.
panel.grid.major = element_blank(),
panel.grid.minor = element_blank(),
# Remove axis text and titles for maps.
axis.text = element_blank(),
axis.title = element_blank(),
legend.title = element_text(face = "italic",
family = "anonymous",
size = base_size - 1,
hjust = 0.5
),
legend.title.position = "top",
legend.text = element_text(face = "italic",
family = "anonymous",
size = base_size - 3,
hjust = 0.5
),
legend.key.width = unit(2, "cm"),
legend.key.height = unit(0.5, "cm"),
legend.background = element_rect(fill = "#f5f4f0", color = "#f5f4f0"),
plot.background = element_rect(fill = "#f5f4f0", color = "#f5f4f0"),
panel.background = element_rect(fill = "#f5f4f0", color = "#f5f4f0"),
plot.margin = unit(c(1, 1, 1, 1), "cm")
)
}
# Load Census API key from environment.
census_api_key <- Sys.getenv("CENSUS_API_KEY")
# Load raw bike share data from CSV.
bike_data <- read.csv("data/indego_2024_2025.csv")
# Define multiple date format patterns to handle inconsistent formatting.
date_formats <- c(
"%m/%d/%Y %H:%M", # 1/1/2020 10:30
"%Y-%m-%d %H:%M:%S", # 2020-01-01 10:30:00
"%m/%d/%y %H:%M", # 1/1/20 10:30
"%m/%d/%Y %I:%M:%S %p", # 1/1/2020 10:30:00 AM/PM
"%m/%d/%Y %I:%M %p" # 1/1/2020 10:30 AM/PM
)
# Parse dates and clean data.
bike_data <- bike_data %>%
mutate(
# Parse start and end times with multiple format options.
start_datetime_new = parse_date_time(start_time, orders = date_formats),
end_datetime_new = parse_date_time(end_time, orders = date_formats)
) %>%
filter(
# Remove rows with unparseable dates.
!is.na(start_datetime_new),
!is.na(end_datetime_new),
# Remove trips without station IDs.
!is.na(start_station_id),
# Remove trips with less than zero duration.
duration > 0,
# Filter to Philadelphia using bounding box.
start_lon >= -75.30, start_lon <= -74.95,
start_lat >= 39.85, start_lat <= 40.20
) %>%
mutate(
# Replace og datetime columns with cleaned versions.
start_time = start_datetime_new,
end_time = end_datetime_new,
# Get date component for daily aggregation.
date = as_date(start_time),
# Get year for filtering.
year = year(start_time),
# Round to nearest hour.
# Creates hourly intervals.
interval60 = floor_date(start_time, unit = "hour"),
# Create quarter-year label.
quarter_year = paste0("Q", quarter(start_time), " ", year(start_time))
) %>%
# Remove temporary datetime columns.
select(-c(start_datetime_new, end_datetime_new))
# Filter to 2025 Q1 data.
# Q1 includes January, February, March.
bike_q1 <- bike_data %>%
filter(year == 2025, quarter(start_time) == 1)
# Print summary statistics for Q1.
cat("2025 Q1 Trips:", format(nrow(bike_q1), big.mark = ","), "\n")
cat("Date Range:", format(min(bike_q1$date), "%Y-%m-%d"),
"to", format(max(bike_q1$date), "%Y-%m-%d"), "\n\n")
cat("Start Stations:", length(unique(bike_q1$start_station)), "\n")
# Show trip type distribution.
table(bike_q1$trip_route_category)
# Show passholder type distribution.
table(bike_q1$passholder_type)
# Show bike type distribution.
table(bike_q1$bike_type)
# Filter to 2024 Q4 data.
# Q4 includes October, November, December.
bike_q4 <- bike_data %>%
filter(year == 2024, quarter(start_time) == 4)
# Print summary statistics for Q4.
cat("2024 Q4 Trips:", format(nrow(bike_q4), big.mark = ","), "\n")
cat("Date Range:", format(min(bike_q4$date), "%Y-%m-%d"),
"to", format(max(bike_q4$date), "%Y-%m-%d"), "\n")
cat("Start Stations:", length(unique(bike_q4$start_station)), "\n")
# Show trip type distribution.
table(bike_q4$trip_route_category)
# Show passholder type distribution.
table(bike_q4$passholder_type)
# Show bike type distribution.
table(bike_q4$bike_type)
#| message: false
#| warning: false
#| fig-dpi: 300
#| fig-height: 8
#| fig-width: 12
# Filter weather to Q1 date range.
weather_q1 <- weather_clean %>%
filter(
interval60 >= min(panel_q1_base$interval60),
interval60 <= max(panel_q1_base$interval60)
)
# Create Q1 temperature plot.
weather_q1_plot <- ggplot(weather_q1, aes(interval60, temp)) +
# Plot hourly temperature as line.
geom_line(color = "#00a557") +
# Add smoothed trend.
geom_smooth(se = FALSE, color = "#ff4100") +
labs(
title = "Philadelphia Temperature",
subtitle = "2025 Q1",
x = "Date", y = "Temperature (°F)"
) +
theme_plot()
# Filter weather to Q4 date range.
weather_q4_daily <- weather_clean %>%
filter(
interval60 >= min(panel_q4_base$interval60),
interval60 <= max(panel_q4_base$interval60)
)
# Create Q4 temperature plot.
weather_q4_daily_plot <- ggplot(weather_q4_daily, aes(interval60, temp)) +
geom_line(color = "#00a557") +
geom_smooth(se = FALSE, color = "#ff4100") +
labs(
title = "Philadelphia Temperature",
subtitle = "2024 Q4",
x = "Date", y = "Temperature (°F)"
) +
theme_plot()
# Aggregate to monthly averages for smoother visualization.
weather_q4_monthly <- weather_clean %>%
group_by(year = year(interval60), month = month(interval60)) %>%
summarize(
temp = mean(temp, na.rm = TRUE),
date_month = make_date(year, month, 1),
.groups = "drop"
)
# Stack temperature plots vertically.
weather_q1_plot / weather_q4_daily_plot
